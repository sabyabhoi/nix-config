{
  "modstruct": {
    "prefix": "modstruct",
    "body": [
      "struct Modular {",
      "  int value;",
      "  static const int MOD_value = MOD;",
      "",
      "  Modular(long long v = 0) { value = v % MOD; if (value < 0) value += MOD;}",
      "  Modular(long long a, long long b) : value(0){ *this += a; *this /= b;}",
      "",
      "  Modular& operator+=(Modular const& b) {value += b.value; if (value >= MOD) value -= MOD; return *this;}",
      "  Modular& operator-=(Modular const& b) {value -= b.value; if (value < 0) value += MOD;return *this;}",
      "  Modular& operator*=(Modular const& b) {value = (long long)value * b.value % MOD;return *this;}",
      "",
      "  friend Modular mexp(Modular a, long long e) {",
      "    Modular res = 1; while (e) { if (e&1) res *= a; a *= a; e >>= 1; }",
      "    return res;",
      "  }",
      "  friend Modular inverse(Modular a) { return mexp(a, MOD - 2); }",
      "",
      "  Modular& operator/=(Modular const& b) { return *this *= inverse(b); }",
      "  friend Modular operator+(Modular a, Modular const b) { return a += b; }",
      "  friend Modular operator-(Modular a, Modular const b) { return a -= b; }",
      "  friend Modular operator-(Modular const a) { return 0 - a; }",
      "  friend Modular operator*(Modular a, Modular const b) { return a *= b; }",
      "  friend Modular operator/(Modular a, Modular const b) { return a /= b; }",
      "  friend std::ostream& operator<<(std::ostream& os, Modular const& a) {return os << a.value;}",
      "  friend bool operator==(Modular const& a, Modular const& b) {return a.value == b.value;}",
      "  friend bool operator!=(Modular const& a, Modular const& b) {return a.value != b.value;}",
      "};"
    ],
    "description": "Neet structure for Modular Arithmetic"
  },
  "modfunc": {
    "prefix": "modfunc",
    "body": [
      "ll mod_add(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a + b) % m) + m) % m;",
      "}",
      "ll mod_mul(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a * b) % m) + m) % m;",
      "}",
      "ll mod_sub(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a - b) % m) + m) % m;",
      "}",
      "ll mod_exp(ll a, ll b, ll mod) {",
      "  ll res = 1;",
      "  while (b > 0) {",
      "    if (b & 1)",
      "      res = (res * a) % mod;",
      "    a = (a * a) % mod;",
      "    b = b >> 1;",
      "  }",
      "  return res;",
      "}",
      "ll mod_inv(ll a, ll m) { return mod_exp(a, m - 2, m); }",
      "ll mod_div(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (mod_mul(a, mod_inv(b, m), m) + m) % m;",
      "} // only for prime m",
      ""
    ],
    "description": "Modular Arithmetic Functions"
  },
  "nCr": {
    "prefix": [
      "choose",
      "ncr"
    ],
    "body": [
      "// Make sure to set the size accordingly",
      "const int SZ = 1e6 + 1; ",
      "int fact[SZ], ifact[SZ];",
      "",
      "void init_fact() {",
      "  fact[0] = fact[1] = 1;",
      "",
      "  FOR(i, 1, SZ) fact[i] = mod_mul(fact[i - 1], i, MOD);",
      "",
      "  ifact[SZ - 1] = mod_inv(fact[SZ - 1], MOD);",
      "  for (int i = SZ - 2; i >= 0; --i)",
      "    ifact[i] = mod_mul(ifact[i + 1], i + 1, MOD);",
      "}",
      "",
      "int choose(int n, int r) {",
      "  return mod_mul(mod_mul(fact[n], ifact[r], MOD), ifact[n - r], MOD);",
      "}"
    ],
    "description": "nCr with precomputation"
  },
  "cc": {
    "prefix": "cc",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "#define deb(x) cout << #x << \" = \" << x << endl",
      "",
      "#define int long long int",
      "",
      "#define FOR(i, s, n) for (int i = (s); i <= (n); ++i)",
      "#define ROF(i, s, n) for (int i = (s); i >= (n); --i)",
      "",
      "#define sz(a) (int)a.size()",
      "#define all(a) a.begin(), a.end()",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef vector<int> vi;",
      "typedef vector<vi> vvi;",
      "typedef pair<int, int> pii;",
      "typedef vector<pii> vp;",
      "typedef vector<bool> vb;",
      "typedef vector<vb> vvb;",
      "typedef vector<string> vs;",
      "typedef vector<vector<string>> vvs;",
      "typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag,",
      "             tree_order_statistics_node_update>",
      "    pbds; // find_by_order, order_of_key",
      "const ll MOD = 1e9 + 7;",
      "const ll INF = 1e18;",
      "",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll getRandomNumber(ll l, ll r) { // get random number in [l, r] (both inclusive)",
      "  return uniform_int_distribution<ll>(l, r)(rng);",
      "}",
      "",
      "template <typename T1, typename T2>",
      "std::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &p) {",
      "  os << \"(\" << p.first << \", \" << p.second << \")\";",
      "  return os;",
      "}",
      "",
      "template <typename ele_type>",
      "ostream &operator<<(ostream &os, const vector<ele_type> &vect_name) {",
      "  for (auto itr : vect_name) {",
      "    os << itr << \" \";",
      "  }",
      "  return os;",
      "}",
      "",
      "const int N = 2e5 + 1;",
      "",
      "void solve() {",
      "  $1",
      "}",
      "",
      "int32_t main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  int t;",
      "  cin >> t;",
      "  while (t--)",
      "    solve();",
      "  return 0;",
      "}"
    ],
    "description": "Competitive coding template"
  },
  "spf": {
    "prefix": "spf",
    "body": [
      "const int N = 2e5 + 1;",
      "vi spf(N + 1);",
      "",
      "void init_spf() {",
      "  for (int i = 0; i <= N; ++i)",
      "    spf[i] = i;",
      "",
      "  for (int i = 2; i <= N; ++i) {",
      "    if (spf[i] != i)",
      "      continue;",
      "    for (int j = i * i; j <= N; j += i)",
      "      spf[j] = min(spf[j], i);",
      "  }",
      "}"
    ],
    "description": "Smallest Prime Factor"
  },
  "interact": {
    "prefix": "interact",
    "body": [
      "struct Interactor {",
      "  int hiddenNumber;",
      "  int maxQueries;",
      "  int queries;",
      "",
      "  Interactor() {",
      "    hiddenNumber = getRandomNumber(2, 100);",
      "    maxQueries = 20;",
      "    queries = 0;",
      "  }",
      "",
      "  string query(int val) {",
      "    assert(queries < maxQueries);",
      "    queries++;",
      "",
      "    return hiddenNumber % val == 0 ? \"yes\" : \"no\";",
      "  }",
      "",
      "  void answer(int ans) {",
      "    if (ans == hiddenNumber) {",
      "      cout << \"PASSED\" << endl;",
      "    } else {",
      "      cout << \"FAILED\" << endl;",
      "      cout << \"Actual value: \" << hiddenNumber << \"\tValue Received: \" << ans",
      "           << endl;",
      "    }",
      "  }",
      "};"
    ],
    "description": "Interactor checking structure"
  },
  "binexp": {
    "prefix": "binexp",
    "body": [
      "int binexp(int a, int b) {",
      "  int res = 1;",
      "  while (b) {",
      "    if (b & 1)",
      "      res = res * a;",
      "    a = a * a;",
      "    b >>= 1ll;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "Binary Exponentiation Algorithm"
  },
  "dsu": {
    "prefix": [
      "dsu",
      "unionfind",
      "disjoint"
    ],
    "body": [
      "class DSU {",
      "  int n;",
      "",
      "public:",
      "  vi parent;",
      "  DSU(int sz) : n(sz), parent(vi(sz, -1)) {}",
      "",
      "  int find(int x) {",
      "    while (parent[x] >= 0)",
      "      x = parent[x];",
      "    return x;",
      "  }",
      "",
      "  void takeUnion(int a, int b) {",
      "    a = find(a);",
      "    b = find(b);",
      "    if (a != b) {",
      "      if (parent[a] > parent[b])",
      "        swap(a, b);",
      "      parent[a] += parent[b];",
      "      parent[b] = a;",
      "    }",
      "  }",
      "};"
    ],
    "description": "Disjoint Set Union / UnionFind"
  },
  "segment_tree": {
    "prefix": [
      "segtree",
      "segmenttree",
      "segment_tree"
    ],
    "body": [
      "class SegmentTree {",
      "",
      "  vi arr;",
      "  int n;",
      "",
      "  int build(const vi &v, int l, int r, int i) {",
      "    if (l == r) {",
      "      return arr[i] = v[l];",
      "    }",
      "",
      "    int m = l + (r - l) / 2;",
      "    return arr[i] = build(v, l, m, 2 * i + 1) +",
      "                    build(v, m + 1, r, 2 * i + 2);",
      "  }",
      "",
      "  int query(int i, int l, int r, int ql, int qr) {",
      "    if (l == ql and r == qr)",
      "      return arr[i];",
      "",
      "    int m = l + (r - l) / 2;",
      "",
      "    if (l <= ql and qr <= m)",
      "      return query(2 * i + 1, l, m, ql, qr);",
      "    else if (m + 1 <= ql and qr <= r)",
      "      return query(2 * i + 2, m + 1, r, ql, qr);",
      "    else",
      "      return query(2 * i + 1, l, m, ql, m) +",
      "             query(2 * i + 2, m + 1, r, m + 1, qr);",
      "  }",
      "",
      "  void update(int l, int r, int arr_ix, int i, int val) {",
      "    if (l == r and l == i) {",
      "      arr[arr_ix] = val;",
      "      return;",
      "    }",
      "",
      "    int m = l + (r - l) / 2, left_ix = 2 * arr_ix + 1,",
      "        right_ix = 2 * arr_ix + 2;",
      "    if (i <= m) {",
      "      update(l, m, left_ix, i, val);",
      "    } else {",
      "      update(m + 1, r, right_ix, i, val);",
      "    }",
      "",
      "    arr[arr_ix] = arr[left_ix] + arr[right_ix];",
      "  }",
      "",
      "public:",
      "  SegmentTree(const vi &v) {",
      "    n = sz(v);",
      "    arr = vi(2 * n + 1, -1);",
      "    build(v, 0, n - 1, 0);",
      "  }",
      "",
      "  int query(int l, int r) { return query(0, 0, n - 1, l, r); }",
      "",
      "  void update(int i, int val) { update(0, n - 1, 0, i, val); }",
      "};"
    ],
    "description": "Segment Tree"
  }
}
