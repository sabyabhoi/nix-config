{
  "cc": {
    "prefix": "cc",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "#define deb(x) cout << #x << \" = \" << x << endl",
      "",
      "#define REP(i, n) for (int i = 0; i < (n); ++i)",
      "#define FOR(i, s, n) for (int i = (s); i < (n); ++i)",
      "#define int long long int",
      "#define sz(a) (int)a.size()",
      "#define all(a) a.begin(), a.end()",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef vector<int> vi;",
      "typedef vector<vi> vvi;",
      "typedef pair<int, int> pii;",
      "typedef vector<pii> vp;",
      "typedef vector<bool> vb;",
      "typedef vector<vb> vvb;",
      "typedef vector<string> vs;",
      "typedef vector<vector<string>> vvs;",
      "typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag,",
      "             tree_order_statistics_node_update>",
      "    pbds; // find_by_order, order_of_key",
      "const ll MOD = 1e9 + 7;",
      "const ll INF = LONG_LONG_MAX;",
      "",
      "ll mod_add(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a + b) % m) + m) % m;",
      "}",
      "ll mod_mul(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a * b) % m) + m) % m;",
      "}",
      "ll mod_sub(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a - b) % m) + m) % m;",
      "}",
      "ll mod_exp(ll a, ll b, ll mod) {",
      "  ll res = 1;",
      "  while (b > 0) {",
      "    if (b & 1)",
      "      res = (res * a) % mod;",
      "    a = (a * a) % mod;",
      "    b = b >> 1;",
      "  }",
      "  return res;",
      "}",
      "ll mod_inv(ll a, ll m) { return mod_exp(a, m - 2, m); }",
      "ll mod_div(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (mod_mul(a, mod_inv(b, m), m) + m) % m;",
      "} // only for prime m",
      "",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll getRandomNumber(ll l, ll r) { // get random number in [l, r] (both inclusive)",
      "  return uniform_int_distribution<ll>(l, r)(rng);",
      "}",
      "",
      "template <typename T1, typename T2>",
      "std::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &p) {",
      "  os << \"(\" << p.first << \", \" << p.second << \")\";",
      "  return os;",
      "}",
      "",
      "template <typename ele_type>",
      "ostream &operator<<(ostream &os, const vector<ele_type> &vect_name) {",
      "  for (auto itr : vect_name) {",
      "    os << itr << \" \";",
      "  }",
      "  return os;",
      "}",
      "",
      "void solve() {",
      "  $1",
      "}",
      "",
      "int32_t main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  int t;",
      "  cin >> t;",
      "  while (t--)",
      "    solve();",
      "  return 0;",
      "}"
    ],
    "description": "Competitive coding template"
  },
  "spf": {
    "prefix": "spf",
    "body": [
      "const int N = 1e5 + 1;",
      "vi spf(N + 1);",
      "",
      "void init_spf() {",
      "  for (int i = 0; i <= N; ++i)",
      "    spf[i] = i;",
      "",
      "  for (int i = 2; i <= N; ++i) {",
      "    if (spf[i] != i)",
      "      continue;",
      "    for (int j = i * i; j <= N; j += i)",
      "      spf[j] = min(spf[j], i);",
      "  }",
      "}"
    ],
    "description": "Smallest Prime Factor"
  },
  "interact": {
    "prefix": "interact",
    "body": [
      "struct Interactor {",
      "  int hiddenNumber;",
      "  int maxQueries;",
      "  int queries;",
      "",
      "  Interactor() {",
      "    hiddenNumber = getRandomNumber(2, 100);",
      "    maxQueries = 20;",
      "    queries = 0;",
      "  }",
      "",
      "  string query(int val) {",
      "    assert(queries < maxQueries);",
      "    queries++;",
      "",
      "    return hiddenNumber % val == 0 ? \"yes\" : \"no\";",
      "  }",
      "",
      "  void answer(int ans) {",
      "    if (ans == hiddenNumber) {",
      "      cout << \"PASSED\" << endl;",
      "    } else {",
      "      cout << \"FAILED\" << endl;",
      "      cout << \"Actual value: \" << hiddenNumber << \"\tValue Received: \" << ans",
      "           << endl;",
      "    }",
      "  }",
      "};"
    ],
    "description": "Interactor checking structure"
  },
  "binexp": {
    "prefix": "binexp",
    "body": [
      "int binexp(int a, int b) {",
      "  int res = 1;",
      "  while (b) {",
      "    if (b & 1)",
      "      res = res * a;",
      "    a = a * a;",
      "    b >>= 1ll;",
      "  }",
      "  return res;",
      "}"
    ],
    "description": "Binary Exponentiation Algorithm"
  },
  "dsu": {
    "prefix": ["dsu", "unionfind", "disjoint"],
    "body": [
      "class DSU {",
      "  int n;",
      "",
      "public:",
      "  vi parent;",
      "  DSU(int sz) : n(sz), parent(vi(sz, -1)) {}",
      "",
      "  int find(int x) {",
      "    while (parent[x] >= 0)",
      "      x = parent[x];",
      "    return x;",
      "  }",
      "",
      "  void takeUnion(int a, int b) {",
      "    a = find(a);",
      "    b = find(b);",
      "    if (a != b) {",
      "      if (parent[a] > parent[b])",
      "        swap(a, b);",
      "      parent[a] += parent[b];",
      "      parent[b] = a;",
      "    }",
      "  }",
      "};"
    ],
    "description": "Disjoint Set Union / UnionFind"
  }
}
