{
  "cc": {
    "prefix": "cc",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "#define deb(x) cout << #x << \" = \" << x << endl",
      "",
      "#define REP(i, n) for (int i = 0; i < (n); ++i)",
      "#define FOR(i, s, n) for (int i = (s); i < (n); ++i)",
      "#define int long long int",
      "#define sz(a) (int)a.size()",
      "#define all(a) a.begin(), a.end()",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "typedef long long ll;",
      "typedef unsigned long long ull;",
      "typedef vector<int> vi;",
      "typedef vector<vi> vvi;",
      "typedef pair<int, int> pii;",
      "typedef vector<pii> vp;",
      "typedef vector<bool> vb;",
      "typedef vector<vb> vvb;",
      "typedef vector<string> vs;",
      "typedef vector<vector<string>> vvs;",
      "typedef tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag,",
      "             tree_order_statistics_node_update>",
      "    pbds; // find_by_order, order_of_key",
      "const ll MOD = 1e9 + 7;",
      "const ll INF = LONG_LONG_MAX;",
      "",
      "ll mod_add(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a + b) % m) + m) % m;",
      "}",
      "ll mod_mul(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a * b) % m) + m) % m;",
      "}",
      "ll mod_sub(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (((a - b) % m) + m) % m;",
      "}",
      "ll mod_exp(ll a, ll b, ll mod) {",
      "  ll res = 1;",
      "  while (b > 0) {",
      "    if (b & 1)",
      "      res = (res * a) % mod;",
      "    a = (a * a) % mod;",
      "    b = b >> 1;",
      "  }",
      "  return res;",
      "}",
      "ll mod_inv(ll a, ll m) { return mod_exp(a, m - 2, m); }",
      "ll mod_div(ll a, ll b, ll m) {",
      "  a = a % m;",
      "  b = b % m;",
      "  return (mod_mul(a, mod_inv(b, m), m) + m) % m;",
      "} // only for prime m",
      "",
      "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
      "ll getRandomNumber(ll l, ll r) { // get random number in [l, r] (both inclusive)",
      "  return uniform_int_distribution<ll>(l, r)(rng);",
      "}",
      "",
      "template <typename T1, typename T2>",
      "std::ostream &operator<<(std::ostream &os, const std::pair<T1, T2> &p) {",
      "  os << \"(\" << p.first << \", \" << p.second << \")\";",
      "  return os;",
      "}",
      "",
      "template <typename ele_type>",
      "ostream &operator<<(ostream &os, const vector<ele_type> &vect_name) {",
      "  for (auto itr : vect_name) {",
      "    os << itr << \" \";",
      "  }",
      "  return os;",
      "}",
      "",
      "void solvePositive(vi &a, int n, vp &ans) {",
      "  REP(i, n - 1) {",
      "    if (a[i + 1] < a[i]) {",
      "      a[i + 1] += a[i];",
      "      ans.push_back({i + 2, i + 1});",
      "    }",
      "  }",
      "}",
      "",
      "void solveNegative(vi &a, int n, vp &ans) {",
      "  for (int i = n - 1; i > 0; --i) {",
      "    if (a[i - 1] > a[i]) {",
      "      a[i - 1] += a[i];",
      "      ans.push_back({i, i + 1});",
      "    }",
      "  }",
      "}",
      "",
      "void solve() {",
      "  $1",
      "}",
      "",
      "int32_t main() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "",
      "  int t;",
      "  cin >> t;",
      "  while (t--)",
      "    solve();",
      "  return 0;",
      "}"
    ],
    "description": "Competitive coding template"
  },
  "spf": {
    "prefix": "spf",
    "body": [
      "const int N = 1e5 + 1;",
      "vi spf(N + 1);",
      "",
      "void init_spf() {",
      "  for (int i = 0; i <= N; ++i)",
      "    spf[i] = i;",
      "",
      "  for (int i = 2; i <= N; ++i) {",
      "    if (spf[i] != i)",
      "      continue;",
      "    for (int j = i * i; j <= N; j += i)",
      "      spf[j] = min(spf[j], i);",
      "  }",
      "}"
    ],
    "description": "Smallest Prime Factor"
  }
}
